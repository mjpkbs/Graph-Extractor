<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ê·¸ë˜í”„ í”½ì…€ ì¶”ì¶œê¸° / Graph Pixel Extractor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 28px;
            font-weight: 600;
            margin-bottom: 8px;
        }

        .header p {
            opacity: 0.9;
            font-size: 14px;
        }

        .main {
            display: grid;
            grid-template-columns: 320px 1fr;
            min-height: 600px;
        }

        .sidebar {
            background: #f8f9fa;
            border-right: 1px solid #e0e0e0;
            padding: 20px;
            overflow-y: auto;
        }

        .section {
            margin-bottom: 20px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e0e0e0;
        }

        .section:last-child {
            border-bottom: none;
        }

        .section h3 {
            font-size: 15px;
            margin-bottom: 12px;
            color: #333;
            font-weight: 600;
        }

        .input-group {
            margin-bottom: 12px;
        }

        .input-group label {
            display: block;
            font-size: 13px;
            color: #555;
            margin-bottom: 6px;
            font-weight: 500;
        }

        .input-group input, .input-group select {
            width: 100%;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 13px;
            transition: border-color 0.3s;
        }

        .input-group input:focus, .input-group select:focus {
            outline: none;
            border-color: #667eea;
        }

        .upload-zone {
            border: 3px dashed #ddd;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            background: #fafafa;
            margin-bottom: 15px;
        }

        .upload-zone:hover {
            border-color: #667eea;
            background: #f0f4ff;
        }

        .upload-zone.dragover {
            border-color: #667eea;
            background: #e3ebff;
            transform: scale(1.02);
        }

        .upload-icon {
            font-size: 40px;
            margin-bottom: 10px;
        }

        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 8px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-success {
            background: #27ae60;
            color: white;
        }

        .btn-success:hover {
            background: #229954;
        }

        .btn-secondary {
            background: #95a5a6;
            color: white;
        }

        .btn-secondary:hover {
            background: #7f8c8d;
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .loading {
            display: none;
            text-align: center;
            padding: 15px;
        }

        .loading.active {
            display: block;
        }

        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .result-section {
            display: none;
        }

        .result-section.active {
            display: block;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }

        .stat-card {
            background: white;
            padding: 12px;
            border-radius: 6px;
            border: 2px solid #e0e0e0;
        }

        .stat-label {
            font-size: 11px;
            color: #666;
            text-transform: uppercase;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 20px;
            font-weight: bold;
            color: #667eea;
        }

        .error {
            background: #fee;
            color: #c00;
            padding: 12px;
            border-radius: 6px;
            margin-top: 10px;
            display: none;
            font-size: 13px;
        }

        .error.active {
            display: block;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 4px;
            font-size: 12px;
            color: #0d47a1;
        }

        .content-area {
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #fileInput {
            display: none;
        }

        .color-picker-group {
            display: grid;
            grid-template-columns: 2fr 1fr;
            gap: 8px;
            align-items: center;
        }

        .color-picker-group input[type="color"] {
            height: 40px;
            padding: 2px;
            cursor: pointer;
        }

        .color-picker-group input[type="number"] {
            text-align: center;
        }

        .slider-group {
            margin-bottom: 10px;
        }

        .slider-group label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #e0e0e0;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
        }

        .canvas-wrapper {
            position: relative;
            display: inline-block;
        }

        #mainCanvas, #overlayCanvas {
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        #overlayCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }

        .color-config {
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            position: relative;
        }

        .color-config-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .color-config-name {
            font-weight: 600;
            font-size: 13px;
            color: #333;
        }

        .btn-remove {
            background: #e74c3c;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            cursor: pointer;
        }

        .btn-remove:hover {
            background: #c0392b;
        }

        .btn-add {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            width: 100%;
            font-weight: 600;
        }

        .btn-add:hover {
            background: #2980b9;
        }

        .color-preview {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 4px;
            border: 2px solid #ddd;
            vertical-align: middle;
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ” ê·¸ë˜í”„ í”½ì…€ ì¶”ì¶œê¸°</h1>
            <p>í”½ì…€ ë‹¨ìœ„ ì •ë°€ ë¶„ì„ìœ¼ë¡œ ê·¸ë˜í”„ë¥¼ SVGë¡œ ë³€í™˜</p>
        </div>

        <div class="main">
            <div class="sidebar">
                <!-- Upload -->
                <div class="section">
                    <h3>ğŸ“ ì´ë¯¸ì§€ ì—…ë¡œë“œ</h3>
                    <div class="upload-zone" id="uploadZone">
                        <div class="upload-icon">ğŸ“Š</div>
                        <div style="font-size: 13px; font-weight: 500;">í´ë¦­ ë˜ëŠ” ë“œë˜ê·¸</div>
                        <input type="file" id="fileInput" accept="image/*">
                    </div>
                </div>

                <!-- Settings -->
                <div class="section">
                    <h3>âš™ï¸ ì¶”ì¶œ ì„¤ì •</h3>
                    
                    <div class="input-group">
                        <label>ğŸ¨ ì¶”ì¶œí•  ê·¸ë˜í”„ ìƒ‰ìƒ</label>
                        <div id="colorConfigList"></div>
                        <button class="btn-add" onclick="addColorConfig()">+ ìƒ‰ìƒ ì¶”ê°€</button>
                    </div>

                    <div class="input-group">
                        <label>ğŸ“ ìƒ˜í”Œë§ ê°„ê²©</label>
                        <select id="samplingInterval">
                            <option value="0.1">0.1í”½ì…€ (ê·¹ì´ˆì •ë°€ - ë§¤ìš° ëŠë¦¼)</option>
                            <option value="0.25" selected>0.25í”½ì…€ (ê·¹ì •ë°€)</option>
                            <option value="0.5">0.5í”½ì…€ (ì„œë¸Œí”½ì…€ ì •ë°€)</option>
                            <option value="1">1í”½ì…€ë§ˆë‹¤ (ì´ˆì •ë°€)</option>
                            <option value="2">2í”½ì…€ë§ˆë‹¤ (ì •ë°€)</option>
                            <option value="5">5í”½ì…€ë§ˆë‹¤ (ë¹ ë¦„)</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label>ğŸ“ˆ ê³¡ì„  ë³´ê°„</label>
                        <select id="interpolation">
                            <option value="none" selected>ì—†ìŒ (ì›ë³¸ ê·¸ëŒ€ë¡œ)</option>
                            <option value="linear">ì„ í˜• ë³´ê°„ (2ë°°)</option>
                            <option value="catmull">Catmull-Rom (4ë°°)</option>
                            <option value="bezier">ë² ì§€ì–´ ê³¡ì„  (8ë°°)</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label>ğŸ” ìŠ¤ìº” ë°©í–¥</label>
                        <select id="scanDirection">
                            <option value="horizontal">ìˆ˜í‰ (ì¢Œâ†’ìš°)</option>
                            <option value="vertical">ìˆ˜ì§ (ìƒâ†’í•˜)</option>
                        </select>
                    </div>

                    <div class="input-group">
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="separateGraphs" style="width: auto; margin-right: 8px;">
                            <span>ğŸ¨ ìƒ‰ìƒë§ˆë‹¤ ê·¸ë˜í”„ ë”°ë¡œ ìƒì„±</span>
                        </label>
                        <small style="color: #666; font-size: 11px; margin-top: 4px; display: block;">
                            ì²´í¬: ìƒ‰ìƒë³„ ë ˆì´ì–´ ë¶„ë¦¬ / ì²´í¬ ì•ˆ í•¨: ë‹¨ì¼ path ë³‘í•©
                        </small>
                    </div>

                    <div class="info-box">
                        <strong>ğŸ’¡ íŒ:</strong><br>
                        â€¢ ì—¬ëŸ¬ ìƒ‰ìƒì„ ë™ì‹œì— ì¶”ì¶œ ê°€ëŠ¥<br>
                        â€¢ ë¹¨ê°„ìƒ‰ ì°¨íŠ¸ â†’ #ff0000<br>
                        â€¢ íŒŒë€ìƒ‰ ì°¨íŠ¸ â†’ #0000ff<br>
                        â€¢ ê° ìƒ‰ìƒë§ˆë‹¤ í—ˆìš©ì˜¤ì°¨ ì¡°ì •<br>
                        <br>
                        <strong>ğŸ¯ ì •ë°€ë„:</strong><br>
                        â€¢ 0.25í”½ì…€ = 4,000+ í¬ì¸íŠ¸<br>
                        â€¢ ë³´ê°„ ì—†ìŒ = ì›ë³¸ ë°ì´í„° ìœ ì§€
                    </div>
                </div>

                <!-- Extract Button -->
                <div class="section">
                    <button class="btn btn-primary" id="extractBtn" disabled>
                        ğŸš€ ê·¸ë˜í”„ ì¶”ì¶œ ì‹œì‘
                    </button>
                    <div class="loading" id="loading">
                        <div class="spinner"></div>
                        <p style="font-size: 12px;">í”½ì…€ ë¶„ì„ ì¤‘...</p>
                    </div>
                </div>

                <!-- Results -->
                <div class="section result-section" id="resultSection">
                    <h3>âœ… ì¶”ì¶œ ì™„ë£Œ</h3>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">í¬ì¸íŠ¸ ìˆ˜</div>
                            <div class="stat-value" id="pointCount">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">ì •ë°€ë„</div>
                            <div class="stat-value" id="precision" style="font-size: 14px;">-</div>
                        </div>
                    </div>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Y ë²”ìœ„</div>
                            <div class="stat-value" id="yRange" style="font-size: 14px;">-</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">X ë²”ìœ„</div>
                            <div class="stat-value" id="xRange" style="font-size: 14px;">-</div>
                        </div>
                    </div>

                    <div class="input-group">
                        <label>SVG ì„  ìƒ‰ìƒ</label>
                        <input type="color" id="svgLineColor" value="#e74c3c">
                    </div>

                    <div class="input-group">
                        <label>SVG ì„  ë‘ê»˜</label>
                        <input type="number" id="svgLineWidth" value="2" min="0.5" max="10" step="0.5">
                    </div>

                    <button class="btn btn-success" onclick="downloadSVG()">
                        â¬‡ SVG ë‹¤ìš´ë¡œë“œ
                    </button>
                    <button class="btn btn-success" onclick="downloadPSD()">
                        ğŸ¨ PSD ë‹¤ìš´ë¡œë“œ (Photopea)
                    </button>
                    <button class="btn btn-secondary" onclick="downloadJSON()">
                        ğŸ“„ JSON ë‹¤ìš´ë¡œë“œ
                    </button>
                    <button class="btn btn-secondary" onclick="copyData()">
                        ğŸ“‹ ë°ì´í„° ë³µì‚¬
                    </button>
                    <button class="btn btn-danger" onclick="clearGraph()">
                        ğŸ—‘ï¸ ê·¸ë ¤ì§„ ê·¸ë˜í”„ ì§€ìš°ê¸°
                    </button>
                    <button class="btn btn-secondary" onclick="resetAll()">
                        ğŸ”„ ì „ì²´ ì´ˆê¸°í™”
                    </button>
                </div>

                <div class="error" id="error"></div>
            </div>

            <div class="content-area">
                <div class="canvas-wrapper" id="canvasWrapper">
                    <canvas id="mainCanvas"></canvas>
                    <canvas id="overlayCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        let imageData = null;
        let extractedData = null;
        let mainCanvas, overlayCanvas, mainCtx, overlayCtx;
        let colorConfigs = [];
        let nextColorId = 1;

        // ê¸°ë³¸ ìƒ‰ìƒ í”„ë¦¬ì…‹
        const colorPresets = [
            { name: 'ë¹¨ê°„ìƒ‰', color: '#ff0000', displayColor: '#00ff00' },
            { name: 'íŒŒë€ìƒ‰', color: '#0000ff', displayColor: '#00ffff' },
            { name: 'ë…¹ìƒ‰', color: '#00ff00', displayColor: '#ff00ff' },
            { name: 'ë¶„í™ìƒ‰', color: '#ff69b4', displayColor: '#ffff00' }
        ];

        window.onload = function() {
            mainCanvas = document.getElementById('mainCanvas');
            overlayCanvas = document.getElementById('overlayCanvas');
            mainCtx = mainCanvas.getContext('2d', { willReadFrequently: true });
            overlayCtx = overlayCanvas.getContext('2d');

            // ê¸°ë³¸ ìƒ‰ìƒ ì¶”ê°€ (ë¹¨ê°„ìƒ‰)
            addColorConfig('#ff0000', 'ë¹¨ê°„ìƒ‰', 40);

            setupEventListeners();
        };

        function setupEventListeners() {
            const uploadZone = document.getElementById('uploadZone');
            const fileInput = document.getElementById('fileInput');

            uploadZone.addEventListener('click', () => fileInput.click());
            fileInput.addEventListener('change', handleFileSelect);

            uploadZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadZone.classList.add('dragover');
            });

            uploadZone.addEventListener('dragleave', () => {
                uploadZone.classList.remove('dragover');
            });

            uploadZone.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadZone.classList.remove('dragover');
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    handleFile(files[0]);
                }
            });

            document.getElementById('extractBtn').addEventListener('click', extractGraph);
        }

        function addColorConfig(color = null, name = null, tolerance = 40) {
            const id = nextColorId++;
            
            // ìë™ ìƒ‰ìƒ ì„ íƒ
            if (!color) {
                const presetIndex = colorConfigs.length % colorPresets.length;
                color = colorPresets[presetIndex].color;
                name = colorPresets[presetIndex].name;
            }
            
            // í‘œì‹œìš© ìƒ‰ìƒ ìë™ ì„ íƒ (ì¶”ì¶œëœ ê·¸ë˜í”„ ì˜¤ë²„ë ˆì´ ìƒ‰ìƒ)
            const displayColors = ['#00ff00', '#00ffff', '#ff00ff', '#ffff00', '#ff8800', '#00ff88'];
            const displayColor = displayColors[colorConfigs.length % displayColors.length];
            
            const config = {
                id: id,
                name: name || `ê·¸ë˜í”„ ${id}`,
                color: color,
                tolerance: tolerance,
                displayColor: displayColor
            };
            
            colorConfigs.push(config);
            renderColorConfigs();
        }

        function removeColorConfig(id) {
            colorConfigs = colorConfigs.filter(c => c.id !== id);
            renderColorConfigs();
        }

        function renderColorConfigs() {
            const container = document.getElementById('colorConfigList');
            container.innerHTML = '';
            
            colorConfigs.forEach((config, index) => {
                const div = document.createElement('div');
                div.className = 'color-config';
                div.innerHTML = `
                    <div class="color-config-header">
                        <div class="color-config-name">
                            <span class="color-preview" style="background-color: ${config.color}"></span>
                            ${config.name}
                        </div>
                        ${colorConfigs.length > 1 ? `<button class="btn-remove" onclick="removeColorConfig(${config.id})">ì‚­ì œ</button>` : ''}
                    </div>
                    <div class="input-group" style="margin-bottom: 8px;">
                        <label style="font-size: 12px;">ì´ë¦„</label>
                        <input type="text" value="${config.name}" 
                               onchange="updateColorConfig(${config.id}, 'name', this.value)"
                               style="padding: 6px; font-size: 12px;">
                    </div>
                    <div class="input-group" style="margin-bottom: 8px;">
                        <label style="font-size: 12px;">ìƒ‰ìƒ</label>
                        <input type="color" value="${config.color}" 
                               onchange="updateColorConfig(${config.id}, 'color', this.value)"
                               style="height: 36px;">
                    </div>
                    <div class="input-group" style="margin-bottom: 0;">
                        <label style="font-size: 12px;">í—ˆìš©ì˜¤ì°¨ (${config.tolerance})</label>
                        <input type="range" min="0" max="100" value="${config.tolerance}" 
                               oninput="updateColorConfig(${config.id}, 'tolerance', this.value)">
                    </div>
                `;
                container.appendChild(div);
            });
        }

        function updateColorConfig(id, field, value) {
            const config = colorConfigs.find(c => c.id === id);
            if (config) {
                if (field === 'tolerance') {
                    config[field] = parseInt(value);
                } else {
                    config[field] = value;
                }
                renderColorConfigs();
            }
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                handleFile(file);
            }
        }

        function handleFile(file) {
            if (!file.type.startsWith('image/')) {
                showError('ì´ë¯¸ì§€ íŒŒì¼ë§Œ ì—…ë¡œë“œ ê°€ëŠ¥í•©ë‹ˆë‹¤.');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    displayImage(img);
                    document.getElementById('extractBtn').disabled = false;
                    hideError();
                };
                img.onerror = function() {
                    showError('ì´ë¯¸ì§€ ë¡œë”© ì‹¤íŒ¨');
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function displayImage(img) {
            const maxWidth = 1000;
            const maxHeight = 800;
            let width = img.width;
            let height = img.height;

            if (width > maxWidth) {
                height = (maxWidth / width) * height;
                width = maxWidth;
            }
            if (height > maxHeight) {
                width = (maxHeight / height) * width;
                height = maxHeight;
            }

            mainCanvas.width = width;
            mainCanvas.height = height;
            overlayCanvas.width = width;
            overlayCanvas.height = height;

            mainCtx.clearRect(0, 0, width, height);
            mainCtx.drawImage(img, 0, 0, width, height);
            
            imageData = mainCtx.getImageData(0, 0, width, height);
        }

        async function extractGraph() {
            if (!imageData) {
                showError('ë¨¼ì € ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ì„¸ìš”.');
                return;
            }

            if (colorConfigs.length === 0) {
                showError('ìµœì†Œ 1ê°œì˜ ìƒ‰ìƒì„ ì¶”ê°€í•˜ì„¸ìš”.');
                return;
            }

            showLoading(true);
            hideError();

            await new Promise(resolve => setTimeout(resolve, 100));

            try {
                const samplingInterval = parseFloat(document.getElementById('samplingInterval').value);
                const scanDirection = document.getElementById('scanDirection').value;
                const interpolationType = document.getElementById('interpolation').value;
                const separateGraphs = document.getElementById('separateGraphs').checked;

                const width = imageData.width;
                const height = imageData.height;

                if (separateGraphs) {
                    // ìƒ‰ìƒë³„ë¡œ ë³„ë„ ê·¸ë˜í”„ ìƒì„±
                    const graphsData = [];

                    for (const config of colorConfigs) {
                        const targetColor = hexToRgb(config.color);
                        const tolerance = config.tolerance;
                        const points = [];

                        if (scanDirection === 'horizontal') {
                            for (let x = 0; x < width; x += samplingInterval) {
                                let bestY = -1;
                                let bestMatch = Infinity;

                                for (let y = 0; y < height; y++) {
                                    const color = getPixelColor(x, y);
                                    const diff = colorDistance(color, targetColor);
                                    
                                    if (diff < tolerance && diff < bestMatch) {
                                        bestMatch = diff;
                                        bestY = y;
                                    }
                                }

                                if (bestY !== -1) {
                                    points.push({ x: x, y: bestY });
                                }
                            }
                        } else {
                            for (let y = 0; y < height; y += samplingInterval) {
                                let bestX = -1;
                                let bestMatch = Infinity;

                                for (let x = 0; x < width; x++) {
                                    const color = getPixelColor(x, y);
                                    const diff = colorDistance(color, targetColor);
                                    
                                    if (diff < tolerance && diff < bestMatch) {
                                        bestMatch = diff;
                                        bestX = x;
                                    }
                                }

                                if (bestX !== -1) {
                                    points.push({ x: bestX, y: y });
                                }
                            }
                        }

                        if (points.length > 0) {
                            const interpolatedPoints = interpolatePoints(points, interpolationType);
                            const yValues = interpolatedPoints.map(p => p.y);
                            const xValues = interpolatedPoints.map(p => p.x);

                            graphsData.push({
                                name: config.name,
                                color: config.color,
                                displayColor: config.displayColor,
                                points: interpolatedPoints,
                                yMin: Math.min(...yValues),
                                yMax: Math.max(...yValues),
                                xMin: Math.min(...xValues),
                                xMax: Math.max(...xValues)
                            });
                        }
                    }

                    if (graphsData.length === 0) {
                        showError('ê·¸ë˜í”„ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ìƒ‰ìƒê³¼ í—ˆìš©ì˜¤ì°¨ë¥¼ ì¡°ì •í•´ë³´ì„¸ìš”.');
                        showLoading(false);
                        return;
                    }

                    // ì „ì²´ ë²”ìœ„ ê³„ì‚°
                    const allYValues = graphsData.flatMap(g => [g.yMin, g.yMax]);
                    const allXValues = graphsData.flatMap(g => [g.xMin, g.xMax]);

                    extractedData = {
                        mode: 'separate',
                        graphs: graphsData,
                        yMin: Math.min(...allYValues),
                        yMax: Math.max(...allYValues),
                        xMin: Math.min(...allXValues),
                        xMax: Math.max(...allXValues),
                        width: width,
                        height: height
                    };
                } else {
                    // ëª¨ë“  ìƒ‰ìƒì„ í•˜ë‚˜ì˜ ê·¸ë˜í”„ë¡œ ë³‘í•©
                    const allPoints = [];

                    if (scanDirection === 'horizontal') {
                        for (let x = 0; x < width; x += samplingInterval) {
                            let bestY = -1;
                            let bestMatch = Infinity;

                            for (let y = 0; y < height; y++) {
                                const color = getPixelColor(x, y);
                                
                                // ëª¨ë“  ìƒ‰ìƒ ì„¤ì •ì— ëŒ€í•´ ì²´í¬
                                for (const config of colorConfigs) {
                                    const targetColor = hexToRgb(config.color);
                                    const tolerance = config.tolerance;
                                    const diff = colorDistance(color, targetColor);
                                    
                                    if (diff < tolerance && diff < bestMatch) {
                                        bestMatch = diff;
                                        bestY = y;
                                    }
                                }
                            }

                            if (bestY !== -1) {
                                allPoints.push({ x: x, y: bestY });
                            }
                        }
                    } else {
                        for (let y = 0; y < height; y += samplingInterval) {
                            let bestX = -1;
                            let bestMatch = Infinity;

                            for (let x = 0; x < width; x++) {
                                const color = getPixelColor(x, y);
                                
                                // ëª¨ë“  ìƒ‰ìƒ ì„¤ì •ì— ëŒ€í•´ ì²´í¬
                                for (const config of colorConfigs) {
                                    const targetColor = hexToRgb(config.color);
                                    const tolerance = config.tolerance;
                                    const diff = colorDistance(color, targetColor);
                                    
                                    if (diff < tolerance && diff < bestMatch) {
                                        bestMatch = diff;
                                        bestX = x;
                                    }
                                }
                            }

                            if (bestX !== -1) {
                                allPoints.push({ x: bestX, y: y });
                            }
                        }
                    }

                    if (allPoints.length === 0) {
                        showError('ê·¸ë˜í”„ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ìƒ‰ìƒê³¼ í—ˆìš©ì˜¤ì°¨ë¥¼ ì¡°ì •í•´ë³´ì„¸ìš”.');
                        showLoading(false);
                        return;
                    }

                    // ë‹¨ì¼ ê·¸ë˜í”„ë¡œ ë³‘í•©
                    const interpolatedPoints = interpolatePoints(allPoints, interpolationType);
                    const yValues = interpolatedPoints.map(p => p.y);
                    const xValues = interpolatedPoints.map(p => p.x);

                    extractedData = {
                        mode: 'merged',
                        points: interpolatedPoints,
                        yMin: Math.min(...yValues),
                        yMax: Math.max(...yValues),
                        xMin: Math.min(...xValues),
                        xMax: Math.max(...xValues),
                        width: width,
                        height: height,
                        colorCount: colorConfigs.length
                    };
                }

                displayResults();
                showLoading(false);
            } catch (error) {
                showError('ì¶”ì¶œ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: ' + error.message);
                showLoading(false);
            }
        }

        function getPixelColor(x, y) {
            const ix = Math.floor(x);
            const iy = Math.floor(y);
            
            if (ix < 0 || ix >= imageData.width || iy < 0 || iy >= imageData.height) {
                return { r: 0, g: 0, b: 0 };
            }

            if (x === ix && y === iy) {
                const idx = (iy * imageData.width + ix) * 4;
                return {
                    r: imageData.data[idx],
                    g: imageData.data[idx + 1],
                    b: imageData.data[idx + 2]
                };
            }

            return bilinearInterpolate(x, y);
        }

        function colorDistance(c1, c2) {
            const dr = c1.r - c2.r;
            const dg = c1.g - c2.g;
            const db = c1.b - c2.b;
            return Math.sqrt(dr * dr + dg * dg + db * db);
        }

        function bilinearInterpolate(x, y) {
            const x0 = Math.floor(x);
            const y0 = Math.floor(y);
            const x1 = Math.min(x0 + 1, imageData.width - 1);
            const y1 = Math.min(y0 + 1, imageData.height - 1);

            const fx = x - x0;
            const fy = y - y0;

            const idx00 = (y0 * imageData.width + x0) * 4;
            const idx10 = (y0 * imageData.width + x1) * 4;
            const idx01 = (y1 * imageData.width + x0) * 4;
            const idx11 = (y1 * imageData.width + x1) * 4;

            const r = (1 - fx) * (1 - fy) * imageData.data[idx00] +
                     fx * (1 - fy) * imageData.data[idx10] +
                     (1 - fx) * fy * imageData.data[idx01] +
                     fx * fy * imageData.data[idx11];

            const g = (1 - fx) * (1 - fy) * imageData.data[idx00 + 1] +
                     fx * (1 - fy) * imageData.data[idx10 + 1] +
                     (1 - fx) * fy * imageData.data[idx01 + 1] +
                     fx * fy * imageData.data[idx11 + 1];

            const b = (1 - fx) * (1 - fy) * imageData.data[idx00 + 2] +
                     fx * (1 - fy) * imageData.data[idx10 + 2] +
                     (1 - fx) * fy * imageData.data[idx01 + 2] +
                     fx * fy * imageData.data[idx11 + 2];

            return { r: Math.round(r), g: Math.round(g), b: Math.round(b) };
        }

        function interpolatePoints(points, type) {
            if (points.length < 2) return points;

            const interpolated = [];

            for (let i = 0; i < points.length - 1; i++) {
                const p0 = points[i];
                const p1 = points[i + 1];

                interpolated.push(p0);

                if (type === 'linear') {
                    const mid = {
                        x: (p0.x + p1.x) / 2,
                        y: (p0.y + p1.y) / 2
                    };
                    interpolated.push(mid);
                } else if (type === 'catmull') {
                    const pMinus1 = i > 0 ? points[i - 1] : p0;
                    const p2 = i < points.length - 2 ? points[i + 2] : p1;

                    for (let t = 0.25; t < 1; t += 0.25) {
                        const t2 = t * t;
                        const t3 = t2 * t;

                        const x = 0.5 * (
                            (2 * p0.x) +
                            (-pMinus1.x + p1.x) * t +
                            (2 * pMinus1.x - 5 * p0.x + 4 * p1.x - p2.x) * t2 +
                            (-pMinus1.x + 3 * p0.x - 3 * p1.x + p2.x) * t3
                        );

                        const y = 0.5 * (
                            (2 * p0.y) +
                            (-pMinus1.y + p1.y) * t +
                            (2 * pMinus1.y - 5 * p0.y + 4 * p1.y - p2.y) * t2 +
                            (-pMinus1.y + 3 * p0.y - 3 * p1.y + p2.y) * t3
                        );

                        interpolated.push({ x, y });
                    }
                } else if (type === 'bezier') {
                    for (let t = 0.125; t < 1; t += 0.125) {
                        const x = (1 - t) * (1 - t) * p0.x + 2 * (1 - t) * t * ((p0.x + p1.x) / 2) + t * t * p1.x;
                        const y = (1 - t) * (1 - t) * p0.y + 2 * (1 - t) * t * ((p0.y + p1.y) / 2) + t * t * p1.y;
                        interpolated.push({ x, y });
                    }
                }
            }

            interpolated.push(points[points.length - 1]);
            return interpolated;
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 255, g: 0, b: 0 };
        }

        function displayResults() {
            const samplingInterval = document.getElementById('samplingInterval').value;
            const interpolationType = document.getElementById('interpolation').value;
            
            if (extractedData.mode === 'separate') {
                const totalPoints = extractedData.graphs.reduce((sum, g) => sum + g.points.length, 0);
                document.getElementById('pointCount').textContent = totalPoints.toLocaleString();
            } else {
                document.getElementById('pointCount').textContent = extractedData.points.length.toLocaleString();
            }
            
            let precisionText = `${samplingInterval}px`;
            if (interpolationType !== 'none') {
                precisionText += ` + ${interpolationType}`;
            }
            document.getElementById('precision').textContent = precisionText;
            
            document.getElementById('yRange').textContent = 
                `${Math.round(extractedData.yMin)} ~ ${Math.round(extractedData.yMax)}`;
            
            document.getElementById('xRange').textContent = 
                `${Math.round(extractedData.xMin)} ~ ${Math.round(extractedData.xMax)}`;

            drawOverlay();
            document.getElementById('resultSection').classList.add('active');
        }

        function drawOverlay() {
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);

            if (!extractedData) return;

            const samplingInterval = document.getElementById('samplingInterval').value;
            const interpolationType = document.getElementById('interpolation').value;

            if (extractedData.mode === 'separate') {
                // ìƒ‰ìƒë³„ ê·¸ë˜í”„ ë”°ë¡œ ê·¸ë¦¬ê¸°
                if (extractedData.graphs.length === 0) return;

                extractedData.graphs.forEach((graph, graphIndex) => {
                    overlayCtx.strokeStyle = graph.displayColor;
                    overlayCtx.lineWidth = 3;
                    overlayCtx.shadowColor = graph.displayColor.replace(')', ', 0.5)').replace('rgb', 'rgba');
                    overlayCtx.shadowBlur = 6;

                    overlayCtx.beginPath();
                    graph.points.forEach((point, i) => {
                        const x = point.x;
                        const y = point.y;

                        if (i === 0) {
                            overlayCtx.moveTo(x, y);
                        } else {
                            overlayCtx.lineTo(x, y);
                        }

                        if (i % 20 === 0) {
                            overlayCtx.fillStyle = graph.displayColor;
                            overlayCtx.fillRect(x - 2, y - 2, 4, 4);
                        }
                    });
                    overlayCtx.stroke();
                });

                overlayCtx.shadowColor = 'transparent';
                overlayCtx.shadowBlur = 0;

                // ì •ë³´ ë°•ìŠ¤
                const boxHeight = 80 + (extractedData.graphs.length * 20);
                overlayCtx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                overlayCtx.fillRect(10, 10, 280, boxHeight);
                
                overlayCtx.fillStyle = 'white';
                overlayCtx.font = 'bold 14px monospace';
                overlayCtx.fillText('ì¶”ì¶œëœ ê·¸ë˜í”„ (ë¶„ë¦¬)', 20, 32);
                overlayCtx.font = '11px monospace';
                
                let yPos = 50;
                extractedData.graphs.forEach(graph => {
                    overlayCtx.fillStyle = graph.displayColor;
                    overlayCtx.fillRect(20, yPos - 8, 12, 12);
                    overlayCtx.fillStyle = 'white';
                    overlayCtx.fillText(`${graph.name}: ${graph.points.length.toLocaleString()}ê°œ`, 38, yPos);
                    yPos += 18;
                });
                
                yPos += 5;
                overlayCtx.fillText(`ìƒ˜í”Œë§: ${samplingInterval}px`, 20, yPos);
                overlayCtx.fillText(`ë³´ê°„: ${interpolationType === 'none' ? 'ì—†ìŒ' : interpolationType}`, 20, yPos + 16);
            } else {
                // ë³‘í•©ëœ ë‹¨ì¼ ê·¸ë˜í”„ ê·¸ë¦¬ê¸°
                if (extractedData.points.length === 0) return;

                overlayCtx.strokeStyle = '#00ff00';
                overlayCtx.lineWidth = 3;
                overlayCtx.shadowColor = 'rgba(0, 255, 0, 0.5)';
                overlayCtx.shadowBlur = 6;

                overlayCtx.beginPath();
                extractedData.points.forEach((point, i) => {
                    const x = point.x;
                    const y = point.y;

                    if (i === 0) {
                        overlayCtx.moveTo(x, y);
                    } else {
                        overlayCtx.lineTo(x, y);
                    }

                    if (i % 20 === 0) {
                        overlayCtx.fillStyle = '#00ff00';
                        overlayCtx.fillRect(x - 2, y - 2, 4, 4);
                    }
                });
                overlayCtx.stroke();

                overlayCtx.shadowColor = 'transparent';
                overlayCtx.shadowBlur = 0;
                
                overlayCtx.fillStyle = 'rgba(0, 0, 0, 0.75)';
                overlayCtx.fillRect(10, 10, 260, 110);
                overlayCtx.fillStyle = '#00ff00';
                overlayCtx.font = 'bold 14px monospace';
                overlayCtx.fillText('ì¶”ì¶œëœ ê·¸ë˜í”„ (ë³‘í•©)', 20, 32);
                overlayCtx.font = '11px monospace';
                overlayCtx.fillStyle = 'white';
                overlayCtx.fillText(`í¬ì¸íŠ¸: ${extractedData.points.length.toLocaleString()}ê°œ`, 20, 50);
                overlayCtx.fillText(`ìƒ˜í”Œë§: ${samplingInterval}px`, 20, 66);
                overlayCtx.fillText(`ë³´ê°„: ${interpolationType === 'none' ? 'ì—†ìŒ' : interpolationType}`, 20, 82);
                if (extractedData.colorCount > 1) {
                    overlayCtx.fillText(`ì¶”ì¶œ ìƒ‰ìƒ: ${extractedData.colorCount}ê°œ ë³‘í•©`, 20, 98);
                }
            }
        }

        function downloadSVG() {
            const svg = generateSVG();
            const blob = new Blob([svg], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'graph-extracted.svg';
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadJSON() {
            const json = JSON.stringify(extractedData, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'graph-data.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function generateSVG() {
            const canvasWidth = extractedData.width;
            const canvasHeight = extractedData.height;
            const aspectRatio = canvasWidth / canvasHeight;
            
            let svgWidth = canvasWidth;
            let svgHeight = canvasHeight;
            
            const maxDimension = 1920;
            if (svgWidth > maxDimension || svgHeight > maxDimension) {
                if (svgWidth > svgHeight) {
                    svgWidth = maxDimension;
                    svgHeight = maxDimension / aspectRatio;
                } else {
                    svgHeight = maxDimension;
                    svgWidth = maxDimension * aspectRatio;
                }
            }

            const lineColor = document.getElementById('svgLineColor').value;
            const lineWidth = document.getElementById('svgLineWidth').value;

            if (extractedData.mode === 'separate') {
                // ìƒ‰ìƒë³„ ê·¸ë˜í”„ ë”°ë¡œ ìƒì„±
                let pathElements = '';
                extractedData.graphs.forEach((graph, index) => {
                    let pathData = '';
                    graph.points.forEach((point, i) => {
                        const x = (point.x / canvasWidth) * svgWidth;
                        const y = (point.y / canvasHeight) * svgHeight;

                        if (i === 0) {
                            pathData += `M ${x.toFixed(3)} ${y.toFixed(3)}`;
                        } else {
                            pathData += ` L ${x.toFixed(3)} ${y.toFixed(3)}`;
                        }
                    });

                    pathElements += `  <g id="${graph.name.replace(/\s+/g, '-')}-layer">
    <path 
      id="${graph.name.replace(/\s+/g, '-')}-path" 
      d="${pathData}" 
      stroke="${graph.color}" 
      stroke-width="${lineWidth}" 
      fill="none" 
      stroke-linecap="round" 
      stroke-linejoin="round"
      vector-effect="non-scaling-stroke"/>
  </g>
`;
                });

                const totalPoints = extractedData.graphs.reduce((sum, g) => sum + g.points.length, 0);

                return `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="${svgWidth.toFixed(0)}" height="${svgHeight.toFixed(0)}" 
     viewBox="0 0 ${svgWidth.toFixed(0)} ${svgHeight.toFixed(0)}" 
     xmlns="http://www.w3.org/2000/svg" 
     xmlns:xlink="http://www.w3.org/1999/xlink" 
     version="1.1">
  <title>Extracted Graphs - ${extractedData.graphs.length} graphs, ${totalPoints} points</title>
  <desc>Y Range: ${Math.round(extractedData.yMin)} ~ ${Math.round(extractedData.yMax)}, X Range: ${Math.round(extractedData.xMin)} ~ ${Math.round(extractedData.xMax)}</desc>
${pathElements}</svg>`;
            } else {
                // ë‹¨ì¼ ë³‘í•© ê·¸ë˜í”„ ìƒì„±
                let pathData = '';
                extractedData.points.forEach((point, i) => {
                    const x = (point.x / canvasWidth) * svgWidth;
                    const y = (point.y / canvasHeight) * svgHeight;

                    if (i === 0) {
                        pathData += `M ${x.toFixed(3)} ${y.toFixed(3)}`;
                    } else {
                        pathData += ` L ${x.toFixed(3)} ${y.toFixed(3)}`;
                    }
                });

                return `<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<svg width="${svgWidth.toFixed(0)}" height="${svgHeight.toFixed(0)}" 
     viewBox="0 0 ${svgWidth.toFixed(0)} ${svgHeight.toFixed(0)}" 
     xmlns="http://www.w3.org/2000/svg" 
     xmlns:xlink="http://www.w3.org/1999/xlink" 
     version="1.1">
  <title>Extracted Graph - ${extractedData.points.length} points</title>
  <desc>Y Range: ${Math.round(extractedData.yMin)} ~ ${Math.round(extractedData.yMax)}, X Range: ${Math.round(extractedData.xMin)} ~ ${Math.round(extractedData.xMax)}</desc>
  <g id="graph-layer">
    <path 
      id="graph-path"
      d="${pathData}" 
      stroke="${lineColor}" 
      stroke-width="${lineWidth}" 
      fill="none" 
      stroke-linecap="round" 
      stroke-linejoin="round"
      vector-effect="non-scaling-stroke"/>
  </g>
</svg>`;
            }
        }

        function copyData() {
            const text = JSON.stringify(extractedData, null, 2);
            navigator.clipboard.writeText(text).then(() => {
                alert('ë°ì´í„°ê°€ í´ë¦½ë³´ë“œì— ë³µì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
            }).catch(() => {
                alert('ë³µì‚¬ ì‹¤íŒ¨. ë¸Œë¼ìš°ì €ê°€ í´ë¦½ë³´ë“œ ì ‘ê·¼ì„ í—ˆìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.');
            });
        }

        function clearGraph() {
            if (!extractedData) return;
            
            if (!confirm('ê·¸ë ¤ì§„ ê·¸ë˜í”„ë¥¼ ì§€ìš°ì‹œê² ìŠµë‹ˆê¹Œ?')) return;
            
            // ì˜¤ë²„ë ˆì´ ìº”ë²„ìŠ¤ë§Œ ì§€ìš°ê¸° (ì›ë³¸ ì´ë¯¸ì§€ëŠ” ìœ ì§€)
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            
            // ì¶”ì¶œ ë°ì´í„° ì´ˆê¸°í™”
            extractedData = null;
            
            // ê²°ê³¼ ì„¹ì…˜ ìˆ¨ê¸°ê¸°
            document.getElementById('resultSection').classList.remove('active');
        }

        function showLoading(show) {
            document.getElementById('loading').classList.toggle('active', show);
            document.getElementById('extractBtn').disabled = show;
        }

        function showError(message) {
            const errorDiv = document.getElementById('error');
            errorDiv.textContent = message;
            errorDiv.classList.add('active');
        }

        function hideError() {
            document.getElementById('error').classList.remove('active');
        }

        function resetAll() {
            if (!confirm('ëª¨ë“  ë°ì´í„°ë¥¼ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?')) return;

            imageData = null;
            extractedData = null;
            mainCtx.clearRect(0, 0, mainCanvas.width, mainCanvas.height);
            overlayCtx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
            document.getElementById('resultSection').classList.remove('active');
            document.getElementById('fileInput').value = '';
            document.getElementById('extractBtn').disabled = true;
            hideError();
        }

        async function downloadPSD() {
            if (!extractedData) {
                alert('ë¨¼ì € ê·¸ë˜í”„ë¥¼ ì¶”ì¶œí•´ì£¼ì„¸ìš”.');
                return;
            }

            try {
                const canvasWidth = extractedData.width;
                const canvasHeight = extractedData.height;
                const lineWidth = document.getElementById('svgLineWidth').value;

                let svgContent;

                if (extractedData.mode === 'separate') {
                    // ìƒ‰ìƒë³„ ê·¸ë˜í”„ ë”°ë¡œ ìƒì„±
                    let pathElements = '';
                    extractedData.graphs.forEach((graph, index) => {
                        let pathData = '';
                        graph.points.forEach((point, i) => {
                            const x = point.x.toFixed(3);
                            const y = point.y.toFixed(3);
                            
                            if (i === 0) {
                                pathData += `M ${x} ${y}`;
                            } else {
                                pathData += ` L ${x} ${y}`;
                            }
                        });
                        
                        const layerId = `${graph.name.replace(/\s+/g, '-')}-path`;
                        pathElements += `  <path id="${layerId}" d="${pathData}" stroke="${graph.color}" stroke-width="${lineWidth}" fill="none" stroke-linecap="round" stroke-linejoin="round"/>\n`;
                    });

                    svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${canvasWidth}" height="${canvasHeight}" viewBox="0 0 ${canvasWidth} ${canvasHeight}" xmlns="http://www.w3.org/2000/svg">
${pathElements}</svg>`;
                } else {
                    // ë‹¨ì¼ ë³‘í•© ê·¸ë˜í”„ ìƒì„±
                    const lineColor = document.getElementById('svgLineColor').value;
                    
                    let pathData = '';
                    extractedData.points.forEach((point, i) => {
                        const x = point.x.toFixed(3);
                        const y = point.y.toFixed(3);
                        
                        if (i === 0) {
                            pathData += `M ${x} ${y}`;
                        } else {
                            pathData += ` L ${x} ${y}`;
                        }
                    });

                    svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${canvasWidth}" height="${canvasHeight}" viewBox="0 0 ${canvasWidth} ${canvasHeight}" xmlns="http://www.w3.org/2000/svg">
  <path id="graph-path" d="${pathData}" stroke="${lineColor}" stroke-width="${lineWidth}" fill="none" stroke-linecap="round" stroke-linejoin="round"/>
</svg>`;
                }

                // Base64 ì¸ì½”ë”©
                const svgBase64 = btoa(unescape(encodeURIComponent(svgContent)));

                // Photopea ì—´ê¸°
                const width = 1400;
                const height = 900;
                const left = (screen.width - width) / 2;
                const top = (screen.height - height) / 2;
                
                const photopeaUrl = `https://www.photopea.com#%7B%22files%22%3A%5B%22data%3Aimage%2Fsvg%2Bxml%3Bbase64%2C${svgBase64}%22%5D%7D`;
                
                const photopeaWindow = window.open(
                    photopeaUrl,
                    'Photopea',
                    `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes`
                );

                if (!photopeaWindow) {
                    alert('íŒì—…ì´ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤. íŒì—… í—ˆìš© í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
                    return;
                }

                // ì‚¬ìš©ìì—ê²Œ ì•ˆë‚´ ë©”ì‹œì§€
                setTimeout(() => {
                    if (extractedData.mode === 'separate') {
                        const layerNames = extractedData.graphs.map(g => `â€¢ ${g.name}`).join('\n');
                        alert(`âœ… Photopeaê°€ ìƒˆ ì°½ì—ì„œ ì—´ë¦½ë‹ˆë‹¤!\n\n` +
                              `ğŸ“ ${extractedData.graphs.length}ê°œì˜ ë²¡í„° íŒ¨ìŠ¤ ë ˆì´ì–´ë¡œ ìƒì„±ë¨:\n${layerNames}\n\n` +
                              `ğŸ’¾ ì €ì¥ ë°©ë²•:\n` +
                              `â€¢ File > Export As > PSD\n` +
                              `â€¢ ë˜ëŠ” Ctrl+S (Mac: Cmd+S)\n\n` +
                              `ğŸ’¡ íŒ:\n` +
                              `â€¢ ê° ë ˆì´ì–´ëŠ” ë…ë¦½ì ìœ¼ë¡œ í¸ì§‘ ê°€ëŠ¥\n` +
                              `â€¢ ë²¡í„° íŒ¨ìŠ¤ì´ë¯€ë¡œ ë¬´ì†ì‹¤ í¸ì§‘\n` +
                              `â€¢ ë ˆì´ì–´ë³„ ìƒ‰ìƒ/ë‘ê»˜ ë³€ê²½ ê°€ëŠ¥`);
                    } else {
                        const colorInfo = extractedData.colorCount > 1 ? 
                            `${extractedData.colorCount}ê°œ ìƒ‰ìƒì´ í•˜ë‚˜ë¡œ ë³‘í•©ë¨\n` : '';
                        
                        alert(`âœ… Photopeaê°€ ìƒˆ ì°½ì—ì„œ ì—´ë¦½ë‹ˆë‹¤!\n\n` +
                              `ğŸ“ ë‹¨ì¼ ë²¡í„° íŒ¨ìŠ¤ ë ˆì´ì–´ë¡œ ìƒì„±ë¨\n` +
                              colorInfo +
                              `ğŸ¨ ë ˆì´ì–´ ì´ë¦„: "graph-path"\n\n` +
                              `ğŸ’¾ ì €ì¥ ë°©ë²•:\n` +
                              `â€¢ File > Export As > PSD\n` +
                              `â€¢ ë˜ëŠ” Ctrl+S (Mac: Cmd+S)\n\n` +
                              `ğŸ’¡ íŒ:\n` +
                              `â€¢ ë²¡í„° íŒ¨ìŠ¤ì´ë¯€ë¡œ ë¬´ì†ì‹¤ í¸ì§‘ ê°€ëŠ¥\n` +
                              `â€¢ Direct Selection Toolë¡œ í¬ì¸íŠ¸ í¸ì§‘\n` +
                              `â€¢ Stroke/Fill ì„¤ì • ë³€ê²½ ê°€ëŠ¥`);
                    }
                }, 500);

            } catch (error) {
                console.error('PSD ìƒì„± ì˜¤ë¥˜:', error);
                alert('PSD ìƒì„± ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message);
            }
        }
    </script>
</body>
</html>